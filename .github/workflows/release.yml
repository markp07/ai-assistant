name: Release

on:
  schedule:
    # Run every Monday at 00:00 UTC
    - cron: '0 0 * * 1'
  workflow_dispatch: # Allow manual trigger

permissions:
  contents: write
  pull-requests: write

jobs:
  release:
    name: Create Release
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          ref: main
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Get latest tag and check for new commits
        id: check_commits
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "Latest tag: $LATEST_TAG"
          
          # Count commits since last tag
          if [ "$LATEST_TAG" != "v0.0.0" ]; then
            COMMIT_COUNT=$(git rev-list $LATEST_TAG..HEAD --count)
          else
            COMMIT_COUNT=$(git rev-list HEAD --count)
          fi
          echo "commit_count=$COMMIT_COUNT" >> $GITHUB_OUTPUT
          echo "Commits since last tag: $COMMIT_COUNT"
          
          # Exit if no new commits
          if [ "$COMMIT_COUNT" -eq 0 ]; then
            echo "No new commits since last tag. Skipping release."
            echo "skip_release=true" >> $GITHUB_OUTPUT
          else
            echo "skip_release=false" >> $GITHUB_OUTPUT
          fi
          
          VERSION=${LATEST_TAG#v}
          echo "current_version=$VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $VERSION"

      - name: Determine version bump
        id: version_bump
        if: steps.check_commits.outputs.skip_release == 'false'
        run: |
          LATEST_TAG="${{ steps.check_commits.outputs.latest_tag }}"
          
          # Get all commits since last tag
          if [ "$LATEST_TAG" != "v0.0.0" ]; then
            COMMITS=$(git log $LATEST_TAG..HEAD --pretty=format:"%s|||%b" --no-merges)
          else
            COMMITS=$(git log --pretty=format:"%s|||%b" --no-merges)
          fi
          
          echo "Analyzing commits for version bump..."
          
          BUMP_TYPE="patch"
          
          # Check for major version indicators
          if echo "$COMMITS" | grep -qE "(BREAKING CHANGE|\\[major\\])"; then
            BUMP_TYPE="major"
          # Check for minor version indicators
          elif echo "$COMMITS" | grep -qE "(feat:|feature/|\\[feature\\]|\\[minor\\])"; then
            BUMP_TYPE="minor"
          # Otherwise default to patch
          fi
          
          echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT
          echo "Version bump type: $BUMP_TYPE"

      - name: Calculate new version
        id: new_version
        if: steps.check_commits.outputs.skip_release == 'false'
        run: |
          CURRENT_VERSION="${{ steps.check_commits.outputs.current_version }}"
          BUMP_TYPE="${{ steps.version_bump.outputs.bump_type }}"
          
          IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
          MAJOR=${VERSION_PARTS[0]}
          MINOR=${VERSION_PARTS[1]}
          PATCH=${VERSION_PARTS[2]}
          
          if [ "$BUMP_TYPE" = "major" ]; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          elif [ "$BUMP_TYPE" = "minor" ]; then
            MINOR=$((MINOR + 1))
            PATCH=0
          else
            PATCH=$((PATCH + 1))
          fi
          
          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"

      - name: Create release branch
        id: create_branch
        if: steps.check_commits.outputs.skip_release == 'false'
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
          BRANCH_NAME="release/v$NEW_VERSION"
          git checkout -b $BRANCH_NAME
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: Update version in pom.xml and package.json
        if: steps.check_commits.outputs.skip_release == 'false'
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
          
          # Update backend version in pom.xml
          sed -i "s/<revision>.*<\/revision>/<revision>$NEW_VERSION<\/revision>/" pom.xml
          echo "Updated pom.xml to version $NEW_VERSION"
          
          # Update frontend version in package.json (using subshell to avoid directory issues)
          (cd frontend && sed -i "s/\"version\": \".*\"/\"version\": \"$NEW_VERSION\"/" package.json)
          echo "Updated package.json to version $NEW_VERSION"

      - name: Generate changelog entry
        id: changelog
        if: steps.check_commits.outputs.skip_release == 'false'
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
          BUMP_TYPE="${{ steps.version_bump.outputs.bump_type }}"
          DATE=$(date +%Y-%m-%d)
          LATEST_TAG="${{ steps.check_commits.outputs.latest_tag }}"
          
          # Get all commits since last tag
          if [ "$LATEST_TAG" != "v0.0.0" ]; then
            COMMITS=$(git log $LATEST_TAG..HEAD --pretty=format:"- %s" --no-merges)
          else
            COMMITS=$(git log --pretty=format:"- %s" --no-merges | head -20)
          fi
          
          # Create new changelog entry
          echo "## [$NEW_VERSION] - $DATE" > /tmp/changelog_entry.md
          echo "" >> /tmp/changelog_entry.md
          echo "### Changed" >> /tmp/changelog_entry.md
          echo "$COMMITS" >> /tmp/changelog_entry.md
          echo "" >> /tmp/changelog_entry.md
          
          if [ -f CHANGELOG.md ]; then
            # Find and extract unreleased content
            UNRELEASED_START=$(grep -n "^## \[Unreleased\]" CHANGELOG.md | cut -d: -f1 | head -1 || echo "")
            
            if [ -n "$UNRELEASED_START" ]; then
              # Find the next section after Unreleased
              UNRELEASED_END=$(tail -n +$((UNRELEASED_START + 1)) CHANGELOG.md | grep -n "^## \[" | head -1 | cut -d: -f1 || echo "")
              
              if [ -n "$UNRELEASED_END" ]; then
                # Extract unreleased content
                UNRELEASED_CONTENT=$(sed -n "$((UNRELEASED_START + 1)),$((UNRELEASED_START + UNRELEASED_END - 1))p" CHANGELOG.md)
                
                # If unreleased has content, prepend it to our changelog entry
                if [ -n "$(echo "$UNRELEASED_CONTENT" | grep -v '^[[:space:]]*$')" ]; then
                  echo "## [$NEW_VERSION] - $DATE" > /tmp/changelog_with_unreleased.md
                  echo "" >> /tmp/changelog_with_unreleased.md
                  echo "$UNRELEASED_CONTENT" >> /tmp/changelog_with_unreleased.md
                  echo "" >> /tmp/changelog_with_unreleased.md
                  echo "### Commits" >> /tmp/changelog_with_unreleased.md
                  echo "$COMMITS" >> /tmp/changelog_with_unreleased.md
                  echo "" >> /tmp/changelog_with_unreleased.md
                  mv /tmp/changelog_with_unreleased.md /tmp/changelog_entry.md
                fi
                
                # Remove unreleased section and insert new version
                INSERT_LINE=$UNRELEASED_START
              else
                INSERT_LINE=$((UNRELEASED_START + 1))
              fi
              
              # Build new changelog
              if [ "$INSERT_LINE" -gt 1 ]; then
                head -n $((INSERT_LINE - 1)) CHANGELOG.md > /tmp/changelog_top.md
              else
                echo -n "" > /tmp/changelog_top.md
              fi
              cat /tmp/changelog_entry.md >> /tmp/changelog_top.md
              tail -n +$((UNRELEASED_START + 1)) CHANGELOG.md | sed '/^## \[Unreleased\]/d' >> /tmp/changelog_top.md
              mv /tmp/changelog_top.md CHANGELOG.md
            else
              # No unreleased section, insert after header
              LINE_NUM=$(grep -n "^## \[" CHANGELOG.md | cut -d: -f1 | head -1)
              
              if [ -n "$LINE_NUM" ]; then
                head -n $((LINE_NUM - 1)) CHANGELOG.md > /tmp/changelog_top.md
                cat /tmp/changelog_entry.md >> /tmp/changelog_top.md
                tail -n +$LINE_NUM CHANGELOG.md >> /tmp/changelog_top.md
                mv /tmp/changelog_top.md CHANGELOG.md
              else
                # Insert after "# Changelog" or similar header
                LINE_NUM=$(grep -n "^# " CHANGELOG.md | cut -d: -f1 | head -1)
                if [ -n "$LINE_NUM" ]; then
                  head -n $((LINE_NUM + 2)) CHANGELOG.md > /tmp/changelog_top.md
                  cat /tmp/changelog_entry.md >> /tmp/changelog_top.md
                  tail -n +$((LINE_NUM + 3)) CHANGELOG.md >> /tmp/changelog_top.md
                  mv /tmp/changelog_top.md CHANGELOG.md
                fi
              fi
            fi
          fi
          
          echo "Updated CHANGELOG.md with version $NEW_VERSION"

      - name: Commit version updates
        if: steps.check_commits.outputs.skip_release == 'false'
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
          git add pom.xml frontend/package.json CHANGELOG.md
          git commit -m "chore: bump version to $NEW_VERSION"

      - name: Push release branch
        if: steps.check_commits.outputs.skip_release == 'false'
        run: |
          BRANCH_NAME="${{ steps.create_branch.outputs.branch_name }}"
          git push origin $BRANCH_NAME

      - name: Create Pull Request
        if: steps.check_commits.outputs.skip_release == 'false'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NEW_VERSION: ${{ steps.new_version.outputs.new_version }}
          BUMP_TYPE: ${{ steps.version_bump.outputs.bump_type }}
        run: |
          BRANCH_NAME="${{ steps.create_branch.outputs.branch_name }}"
          LATEST_TAG="${{ steps.check_commits.outputs.latest_tag }}"
          
          # Get commit list for PR body
          if [ "$LATEST_TAG" != "v0.0.0" ]; then
            COMMITS=$(git log $LATEST_TAG..HEAD --pretty=format:"- %s" --no-merges)
          else
            COMMITS=$(git log HEAD --pretty=format:"- %s" --no-merges | head -20)
          fi
          
          # Create PR body file
          cat > /tmp/pr_body.md << 'EOF'
          ## Release v$NEW_VERSION
          
          This is an automated release PR created by the weekly release workflow.
          
          ### Version Bump Type
          $BUMP_TYPE
          
          ### Changes
          $COMMITS
          
          ### Files Updated
          - `pom.xml` - Backend version updated to $NEW_VERSION
          - `frontend/package.json` - Frontend version updated to $NEW_VERSION
          - `CHANGELOG.md` - Updated with release notes
          
          After merging this PR, a GitHub release and tag will be created automatically.
          EOF
          
          # Substitute variables
          sed -i "s/\$NEW_VERSION/$NEW_VERSION/g" /tmp/pr_body.md
          sed -i "s/\$BUMP_TYPE/$BUMP_TYPE/g" /tmp/pr_body.md
          echo "$COMMITS" > /tmp/commits.txt
          sed -i "/\$COMMITS/r /tmp/commits.txt" /tmp/pr_body.md
          sed -i "/\$COMMITS/d" /tmp/pr_body.md
          
          gh pr create \
            --title "chore: Release v$NEW_VERSION" \
            --body-file /tmp/pr_body.md \
            --base main \
            --head $BRANCH_NAME \
            --label "release"
