name: Release

on:
  schedule:
    # Run every Monday at 00:00 UTC
    - cron: '0 0 * * 1'
  workflow_dispatch: # Allow manual trigger

permissions:
  contents: write

jobs:
  release:
    name: Create Release
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          ref: main
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Get latest tag and check for new commits
        id: check_commits
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "Latest tag: $LATEST_TAG"
          
          # Count commits since last tag
          if [ "$LATEST_TAG" != "v0.0.0" ]; then
            COMMIT_COUNT=$(git rev-list $LATEST_TAG..HEAD --count)
          else
            COMMIT_COUNT=$(git rev-list HEAD --count)
          fi
          echo "commit_count=$COMMIT_COUNT" >> $GITHUB_OUTPUT
          echo "Commits since last tag: $COMMIT_COUNT"
          
          # Exit if no new commits
          if [ "$COMMIT_COUNT" -eq 0 ]; then
            echo "No new commits since last tag. Skipping release."
            echo "skip_release=true" >> $GITHUB_OUTPUT
          else
            echo "skip_release=false" >> $GITHUB_OUTPUT
          fi
          
          VERSION=${LATEST_TAG#v}
          echo "current_version=$VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $VERSION"

      - name: Determine version bump
        id: version_bump
        if: steps.check_commits.outputs.skip_release == 'false'
        run: |
          LATEST_TAG="${{ steps.check_commits.outputs.latest_tag }}"
          
          # Get all commits since last tag
          if [ "$LATEST_TAG" != "v0.0.0" ]; then
            COMMITS=$(git log $LATEST_TAG..HEAD --pretty=format:"%s|||%b" --no-merges)
          else
            COMMITS=$(git log --pretty=format:"%s|||%b" --no-merges)
          fi
          
          echo "Analyzing commits for version bump..."
          
          BUMP_TYPE="patch"
          
          # Check for major version indicators
          if echo "$COMMITS" | grep -qE "(BREAKING CHANGE|\\[major\\])"; then
            BUMP_TYPE="major"
          # Check for minor version indicators
          elif echo "$COMMITS" | grep -qE "(feat:|feature/|\\[feature\\]|\\[minor\\])"; then
            BUMP_TYPE="minor"
          # Otherwise default to patch
          fi
          
          echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT
          echo "Version bump type: $BUMP_TYPE"

      - name: Calculate new version
        id: new_version
        if: steps.check_commits.outputs.skip_release == 'false'
        run: |
          CURRENT_VERSION="${{ steps.check_commits.outputs.current_version }}"
          BUMP_TYPE="${{ steps.version_bump.outputs.bump_type }}"
          
          IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
          MAJOR=${VERSION_PARTS[0]}
          MINOR=${VERSION_PARTS[1]}
          PATCH=${VERSION_PARTS[2]}
          
          if [ "$BUMP_TYPE" = "major" ]; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          elif [ "$BUMP_TYPE" = "minor" ]; then
            MINOR=$((MINOR + 1))
            PATCH=0
          else
            PATCH=$((PATCH + 1))
          fi
          
          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"



      - name: Update version in pom.xml and package.json
        if: steps.check_commits.outputs.skip_release == 'false'
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
          
          # Update backend version in pom.xml
          sed -i "s/<revision>.*<\/revision>/<revision>$NEW_VERSION<\/revision>/" pom.xml
          echo "Updated pom.xml to version $NEW_VERSION"
          
          # Update frontend version in package.json (using subshell to avoid directory issues)
          (cd frontend && sed -i 's/"version":[[:space:]]*"[^"]*"/"version": "'"$NEW_VERSION"'"/' package.json)
          echo "Updated package.json to version $NEW_VERSION"

      - name: Generate changelog entry
        id: changelog
        if: steps.check_commits.outputs.skip_release == 'false'
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
          BUMP_TYPE="${{ steps.version_bump.outputs.bump_type }}"
          DATE=$(date +%Y-%m-%d)
          LATEST_TAG="${{ steps.check_commits.outputs.latest_tag }}"
          
          # Get all commits since last tag
          if [ "$LATEST_TAG" != "v0.0.0" ]; then
            COMMITS=$(git log $LATEST_TAG..HEAD --pretty=format:"- %s" --no-merges)
          else
            COMMITS=$(git log --pretty=format:"- %s" --no-merges | head -20)
          fi
          
          # Create new changelog entry
          echo "## [$NEW_VERSION] - $DATE" > /tmp/changelog_entry.md
          echo "" >> /tmp/changelog_entry.md
          echo "### Changed" >> /tmp/changelog_entry.md
          echo "$COMMITS" >> /tmp/changelog_entry.md
          echo "" >> /tmp/changelog_entry.md
          
          if [ -f CHANGELOG.md ]; then
            # Find and extract unreleased content
            UNRELEASED_START=$(grep -n "^## \[Unreleased\]" CHANGELOG.md | cut -d: -f1 | head -1 || echo "")
            
            if [ -n "$UNRELEASED_START" ]; then
              # Find the next section after Unreleased
              UNRELEASED_END=$(tail -n +$((UNRELEASED_START + 1)) CHANGELOG.md | grep -n "^## \[" | head -1 | cut -d: -f1 || echo "")
              
              if [ -n "$UNRELEASED_END" ]; then
                # Extract unreleased content
                UNRELEASED_CONTENT=$(sed -n "$((UNRELEASED_START + 1)),$((UNRELEASED_START + UNRELEASED_END - 1))p" CHANGELOG.md)
                
                # If unreleased has content, prepend it to our changelog entry
                if [ -n "$(echo "$UNRELEASED_CONTENT" | grep -v '^[[:space:]]*$')" ]; then
                  echo "## [$NEW_VERSION] - $DATE" > /tmp/changelog_with_unreleased.md
                  echo "" >> /tmp/changelog_with_unreleased.md
                  echo "$UNRELEASED_CONTENT" >> /tmp/changelog_with_unreleased.md
                  echo "" >> /tmp/changelog_with_unreleased.md
                  echo "### Commits" >> /tmp/changelog_with_unreleased.md
                  echo "$COMMITS" >> /tmp/changelog_with_unreleased.md
                  echo "" >> /tmp/changelog_with_unreleased.md
                  mv /tmp/changelog_with_unreleased.md /tmp/changelog_entry.md
                fi
                
                # Remove unreleased section and insert new version
                INSERT_LINE=$UNRELEASED_START
              else
                INSERT_LINE=$((UNRELEASED_START + 1))
              fi
              
              # Build new changelog
              if [ "$INSERT_LINE" -gt 1 ]; then
                head -n $((INSERT_LINE - 1)) CHANGELOG.md > /tmp/changelog_top.md
              else
                echo -n "" > /tmp/changelog_top.md
              fi
              cat /tmp/changelog_entry.md >> /tmp/changelog_top.md
              tail -n +$((UNRELEASED_START + 1)) CHANGELOG.md | sed '/^## \[Unreleased\]/d' >> /tmp/changelog_top.md
              mv /tmp/changelog_top.md CHANGELOG.md
            else
              # No unreleased section, insert after header
              LINE_NUM=$(grep -n "^## \[" CHANGELOG.md | cut -d: -f1 | head -1)
              
              if [ -n "$LINE_NUM" ]; then
                head -n $((LINE_NUM - 1)) CHANGELOG.md > /tmp/changelog_top.md
                cat /tmp/changelog_entry.md >> /tmp/changelog_top.md
                tail -n +$LINE_NUM CHANGELOG.md >> /tmp/changelog_top.md
                mv /tmp/changelog_top.md CHANGELOG.md
              else
                # Insert after "# Changelog" or similar header
                LINE_NUM=$(grep -n "^# " CHANGELOG.md | cut -d: -f1 | head -1)
                if [ -n "$LINE_NUM" ]; then
                  head -n $((LINE_NUM + 2)) CHANGELOG.md > /tmp/changelog_top.md
                  cat /tmp/changelog_entry.md >> /tmp/changelog_top.md
                  tail -n +$((LINE_NUM + 3)) CHANGELOG.md >> /tmp/changelog_top.md
                  mv /tmp/changelog_top.md CHANGELOG.md
                fi
              fi
            fi
          fi
          
          echo "Updated CHANGELOG.md with version $NEW_VERSION"

      - name: Commit version updates
        if: steps.check_commits.outputs.skip_release == 'false'
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
          git add pom.xml frontend/package.json CHANGELOG.md
          git commit -m "chore: bump version to $NEW_VERSION [skip ci]" || echo "No changes to commit"
          git push origin main

      - name: Create and push tag
        if: steps.check_commits.outputs.skip_release == 'false'
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
          git tag -a "v$NEW_VERSION" -m "Release version $NEW_VERSION"
          git push origin "v$NEW_VERSION"

      - name: Create GitHub Release
        if: steps.check_commits.outputs.skip_release == 'false'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NEW_VERSION: ${{ steps.new_version.outputs.new_version }}
          BUMP_TYPE: ${{ steps.version_bump.outputs.bump_type }}
        run: |
          LATEST_TAG="${{ steps.check_commits.outputs.latest_tag }}"
          
          # Extract release notes from CHANGELOG.md
          if [ -f CHANGELOG.md ]; then
            # Find the section for this version
            START_LINE=$(grep -n "^## \[$NEW_VERSION\]" CHANGELOG.md | cut -d: -f1 | head -1)
            
            if [ -n "$START_LINE" ]; then
              # Find the next version section
              NEXT_SECTION=$(tail -n +$((START_LINE + 1)) CHANGELOG.md | grep -n "^## \[" | head -1 | cut -d: -f1)
              
              if [ -n "$NEXT_SECTION" ]; then
                END_LINE=$((START_LINE + NEXT_SECTION - 1))
                RELEASE_NOTES=$(sed -n "$((START_LINE)),$((END_LINE))p" CHANGELOG.md)
              else
                RELEASE_NOTES=$(tail -n +$START_LINE CHANGELOG.md)
              fi
            else
              RELEASE_NOTES="See [CHANGELOG.md](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md) for details."
            fi
          else
            RELEASE_NOTES="See [CHANGELOG.md](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md) for details."
          fi
          
          gh release create "v$NEW_VERSION" \
            --title "Release v$NEW_VERSION" \
            --notes "$RELEASE_NOTES" \
            --latest
          
          echo "Created GitHub release for v$NEW_VERSION"
